// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ratelimit.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	ratelimit.proto

It has these top-level messages:
	RateLimitRequest
	RateLimitDescriptor
	DescriptorStatus
	RateLimitResponse
	RateLimit
	RateLimitKeyRequest
	KeyRequestEntry
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DescriptorStatus_Code int32

const (
	DescriptorStatus_UNKNOWN    DescriptorStatus_Code = 0
	DescriptorStatus_OK         DescriptorStatus_Code = 1
	DescriptorStatus_OVER_LIMIT DescriptorStatus_Code = 2
)

var DescriptorStatus_Code_name = map[int32]string{
	0: "UNKNOWN",
	1: "OK",
	2: "OVER_LIMIT",
}
var DescriptorStatus_Code_value = map[string]int32{
	"UNKNOWN":    0,
	"OK":         1,
	"OVER_LIMIT": 2,
}

func (x DescriptorStatus_Code) String() string {
	return proto.EnumName(DescriptorStatus_Code_name, int32(x))
}
func (DescriptorStatus_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type RateLimitRequest struct {
	// All rate limit requests must specify a domain. This enables the configuration to be per
	// application without fear of overlap. E.g., "envoy".
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// All rate limit requests must specify at least one RateLimitDescriptor, but can specify multiple descriptors
	// to be individually evaluated
	Descriptors []*RateLimitDescriptor `protobuf:"bytes,2,rep,name=descriptors" json:"descriptors,omitempty"`
}

func (m *RateLimitRequest) Reset()                    { *m = RateLimitRequest{} }
func (m *RateLimitRequest) String() string            { return proto.CompactTextString(m) }
func (*RateLimitRequest) ProtoMessage()               {}
func (*RateLimitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RateLimitRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *RateLimitRequest) GetDescriptors() []*RateLimitDescriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

type RateLimitDescriptor struct {
	// A list of key value pairs that make up the descriptor
	Entries []*RateLimitDescriptor_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	// Rate limit requests optionally specify the number of hits a request adds to the matched limit. If the
	// value is not set, a request increases the matched limit by 1.
	Hits uint32 `protobuf:"varint,2,opt,name=hits" json:"hits,omitempty"`
	// This is the rate limit the requested for this descriptor. If the rate limit doesn't currently exist for
	// this descriptor it will be created and enforced for subsequent requests
	RateLimit *RateLimit `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit" json:"rate_limit,omitempty"`
}

func (m *RateLimitDescriptor) Reset()                    { *m = RateLimitDescriptor{} }
func (m *RateLimitDescriptor) String() string            { return proto.CompactTextString(m) }
func (*RateLimitDescriptor) ProtoMessage()               {}
func (*RateLimitDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RateLimitDescriptor) GetEntries() []*RateLimitDescriptor_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *RateLimitDescriptor) GetHits() uint32 {
	if m != nil {
		return m.Hits
	}
	return 0
}

func (m *RateLimitDescriptor) GetRateLimit() *RateLimit {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

type RateLimitDescriptor_Entry struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *RateLimitDescriptor_Entry) Reset()                    { *m = RateLimitDescriptor_Entry{} }
func (m *RateLimitDescriptor_Entry) String() string            { return proto.CompactTextString(m) }
func (*RateLimitDescriptor_Entry) ProtoMessage()               {}
func (*RateLimitDescriptor_Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *RateLimitDescriptor_Entry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RateLimitDescriptor_Entry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DescriptorStatus struct {
	// The response code for this descriptor.
	Code DescriptorStatus_Code `protobuf:"varint,1,opt,name=code,enum=pb.gubernator.DescriptorStatus_Code" json:"code,omitempty"`
	// The current limit for the requested span.
	CurrentLimit uint32 `protobuf:"varint,2,opt,name=current_limit,json=currentLimit" json:"current_limit,omitempty"`
	// If Code is not OVER_LIMIT, This is the limit remaining in the current time span.
	LimitRemaining uint32 `protobuf:"varint,3,opt,name=limit_remaining,json=limitRemaining" json:"limit_remaining,omitempty"`
	// Of the number of hits recieved, this is the number of hits that are allowed before the limit was reached.
	// IE: If a service wants to limit the number of recipients are sent an email, and it sends a request to the
	// rate limit service for 1,000 recipents, but only 500 of the 1,000 hits are available before the limit is reached
	// the service will respond with OVER_LIMIT and a `of_hits_accepted` of 500. Indicating the service can
	// send 500 emails of the 1,000 emails it originally wished to send.
	OfHitsAccepted uint32 `protobuf:"varint,4,opt,name=of_hits_accepted,json=ofHitsAccepted" json:"of_hits_accepted,omitempty"`
	// This is the time when the rate limit span will be reset as a unix timestamp.
	ResetTime int64 `protobuf:"varint,5,opt,name=reset_time,json=resetTime" json:"reset_time,omitempty"`
}

func (m *DescriptorStatus) Reset()                    { *m = DescriptorStatus{} }
func (m *DescriptorStatus) String() string            { return proto.CompactTextString(m) }
func (*DescriptorStatus) ProtoMessage()               {}
func (*DescriptorStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DescriptorStatus) GetCode() DescriptorStatus_Code {
	if m != nil {
		return m.Code
	}
	return DescriptorStatus_UNKNOWN
}

func (m *DescriptorStatus) GetCurrentLimit() uint32 {
	if m != nil {
		return m.CurrentLimit
	}
	return 0
}

func (m *DescriptorStatus) GetLimitRemaining() uint32 {
	if m != nil {
		return m.LimitRemaining
	}
	return 0
}

func (m *DescriptorStatus) GetOfHitsAccepted() uint32 {
	if m != nil {
		return m.OfHitsAccepted
	}
	return 0
}

func (m *DescriptorStatus) GetResetTime() int64 {
	if m != nil {
		return m.ResetTime
	}
	return 0
}

type RateLimitResponse struct {
	// If the request for this rate limit is not handled by the host that recieved it, this field will
	// be populated with the host name of the rate limit service that is the corrdinator for the requested
	// rate limit. Clients should send all future requests for this descriptor to this host.
	Coordinator string `protobuf:"bytes,1,opt,name=coordinator" json:"coordinator,omitempty"`
	// A list of DescriptorStatus messages which matches the length of the descriptor list passed
	// in the RateLimitRequest. This can be used by the caller to determine which individual
	// descriptors failed and/or what the currently configured limits are for all of them.
	Statuses []*DescriptorStatus `protobuf:"bytes,2,rep,name=statuses" json:"statuses,omitempty"`
}

func (m *RateLimitResponse) Reset()                    { *m = RateLimitResponse{} }
func (m *RateLimitResponse) String() string            { return proto.CompactTextString(m) }
func (*RateLimitResponse) ProtoMessage()               {}
func (*RateLimitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RateLimitResponse) GetCoordinator() string {
	if m != nil {
		return m.Coordinator
	}
	return ""
}

func (m *RateLimitResponse) GetStatuses() []*DescriptorStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// Defines a rate limit span in seconds and requests per span
type RateLimit struct {
	// The number of requests that can occur during the span before the rate limit is reached
	RequestsPerSpan uint32 `protobuf:"varint,1,opt,name=requests_per_span,json=requestsPerSpan" json:"requests_per_span,omitempty"`
	// Span is the time span the requests_per_span is enforced
	SpanInSeconds int64 `protobuf:"varint,2,opt,name=span_in_seconds,json=spanInSeconds" json:"span_in_seconds,omitempty"`
}

func (m *RateLimit) Reset()                    { *m = RateLimit{} }
func (m *RateLimit) String() string            { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()               {}
func (*RateLimit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RateLimit) GetRequestsPerSpan() uint32 {
	if m != nil {
		return m.RequestsPerSpan
	}
	return 0
}

func (m *RateLimit) GetSpanInSeconds() int64 {
	if m != nil {
		return m.SpanInSeconds
	}
	return 0
}

// This is used by Gubernator clients who already have the domain and descriptors and created a hash key
type RateLimitKeyRequest struct {
	// Requests must specify at least one KeyRequestEntry, but can specify multiple descriptors
	// to be individually evaluated
	Entries []*KeyRequestEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *RateLimitKeyRequest) Reset()                    { *m = RateLimitKeyRequest{} }
func (m *RateLimitKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*RateLimitKeyRequest) ProtoMessage()               {}
func (*RateLimitKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RateLimitKeyRequest) GetEntries() []*KeyRequestEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type KeyRequestEntry struct {
	// The key identifies the specific rate limit the request is for
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Rate limit requests can optionally specify the number of hits a request adds to the matched limit. If the
	// value is not set in the message, a request increases the matched limit by 1.
	Hits uint32 `protobuf:"varint,2,opt,name=hits" json:"hits,omitempty"`
	// This is the rate limit the requested for this descriptor. If the rate limit doesn't currently exist for
	// this descriptor it will be created and enforced for subsequent requests
	RateLimit *RateLimit `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit" json:"rate_limit,omitempty"`
}

func (m *KeyRequestEntry) Reset()                    { *m = KeyRequestEntry{} }
func (m *KeyRequestEntry) String() string            { return proto.CompactTextString(m) }
func (*KeyRequestEntry) ProtoMessage()               {}
func (*KeyRequestEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *KeyRequestEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyRequestEntry) GetHits() uint32 {
	if m != nil {
		return m.Hits
	}
	return 0
}

func (m *KeyRequestEntry) GetRateLimit() *RateLimit {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

func init() {
	proto.RegisterType((*RateLimitRequest)(nil), "pb.gubernator.RateLimitRequest")
	proto.RegisterType((*RateLimitDescriptor)(nil), "pb.gubernator.RateLimitDescriptor")
	proto.RegisterType((*RateLimitDescriptor_Entry)(nil), "pb.gubernator.RateLimitDescriptor.Entry")
	proto.RegisterType((*DescriptorStatus)(nil), "pb.gubernator.DescriptorStatus")
	proto.RegisterType((*RateLimitResponse)(nil), "pb.gubernator.RateLimitResponse")
	proto.RegisterType((*RateLimit)(nil), "pb.gubernator.RateLimit")
	proto.RegisterType((*RateLimitKeyRequest)(nil), "pb.gubernator.RateLimitKeyRequest")
	proto.RegisterType((*KeyRequestEntry)(nil), "pb.gubernator.KeyRequestEntry")
	proto.RegisterEnum("pb.gubernator.DescriptorStatus_Code", DescriptorStatus_Code_name, DescriptorStatus_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RateLimitService service

type RateLimitServiceClient interface {
	// Determine whether rate limiting should take place.
	ShouldRateLimit(ctx context.Context, in *RateLimitRequest, opts ...grpc.CallOption) (*RateLimitResponse, error)
	// Client implementations should use this method since they calculate the key and know which peer to use.
	ShouldRateLimitByKey(ctx context.Context, in *RateLimitKeyRequest, opts ...grpc.CallOption) (*RateLimitResponse, error)
}

type rateLimitServiceClient struct {
	cc *grpc.ClientConn
}

func NewRateLimitServiceClient(cc *grpc.ClientConn) RateLimitServiceClient {
	return &rateLimitServiceClient{cc}
}

func (c *rateLimitServiceClient) ShouldRateLimit(ctx context.Context, in *RateLimitRequest, opts ...grpc.CallOption) (*RateLimitResponse, error) {
	out := new(RateLimitResponse)
	err := grpc.Invoke(ctx, "/pb.gubernator.RateLimitService/ShouldRateLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ShouldRateLimitByKey(ctx context.Context, in *RateLimitKeyRequest, opts ...grpc.CallOption) (*RateLimitResponse, error) {
	out := new(RateLimitResponse)
	err := grpc.Invoke(ctx, "/pb.gubernator.RateLimitService/ShouldRateLimitByKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RateLimitService service

type RateLimitServiceServer interface {
	// Determine whether rate limiting should take place.
	ShouldRateLimit(context.Context, *RateLimitRequest) (*RateLimitResponse, error)
	// Client implementations should use this method since they calculate the key and know which peer to use.
	ShouldRateLimitByKey(context.Context, *RateLimitKeyRequest) (*RateLimitResponse, error)
}

func RegisterRateLimitServiceServer(s *grpc.Server, srv RateLimitServiceServer) {
	s.RegisterService(&_RateLimitService_serviceDesc, srv)
}

func _RateLimitService_ShouldRateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ShouldRateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.gubernator.RateLimitService/ShouldRateLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ShouldRateLimit(ctx, req.(*RateLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ShouldRateLimitByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateLimitKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ShouldRateLimitByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.gubernator.RateLimitService/ShouldRateLimitByKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ShouldRateLimitByKey(ctx, req.(*RateLimitKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RateLimitService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.gubernator.RateLimitService",
	HandlerType: (*RateLimitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShouldRateLimit",
			Handler:    _RateLimitService_ShouldRateLimit_Handler,
		},
		{
			MethodName: "ShouldRateLimitByKey",
			Handler:    _RateLimitService_ShouldRateLimitByKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ratelimit.proto",
}

func init() { proto.RegisterFile("ratelimit.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 588 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x5d, 0xda, 0x6e, 0xa3, 0xb7, 0xeb, 0x9a, 0x5d, 0x26, 0x14, 0x4d, 0x82, 0x55, 0x01, 0x41,
	0x04, 0x52, 0x91, 0xca, 0x03, 0x93, 0x78, 0x62, 0x6c, 0x12, 0x53, 0xc7, 0x8a, 0xdc, 0x31, 0x24,
	0x1e, 0x88, 0xd2, 0xe4, 0x6e, 0xb3, 0x68, 0xe3, 0x60, 0x3b, 0x93, 0xfa, 0xc6, 0x27, 0xf0, 0x5d,
	0xfc, 0x00, 0xbf, 0x83, 0xe2, 0xa4, 0x6d, 0x16, 0x51, 0x8d, 0x07, 0xde, 0x9c, 0x7b, 0xcf, 0x3d,
	0x3e, 0x39, 0x3e, 0x36, 0x74, 0x64, 0xa0, 0x69, 0xc2, 0xa7, 0x5c, 0xf7, 0x12, 0x29, 0xb4, 0xc0,
	0x76, 0x32, 0xee, 0x5d, 0xa5, 0x63, 0x92, 0x71, 0xa0, 0x85, 0x74, 0x13, 0xb0, 0x59, 0xa0, 0xe9,
	0x34, 0x43, 0x30, 0xfa, 0x9e, 0x92, 0xd2, 0xf8, 0x00, 0x36, 0x22, 0x31, 0x0d, 0x78, 0xec, 0x58,
	0x5d, 0xcb, 0x6b, 0xb2, 0xe2, 0x0b, 0x8f, 0xa0, 0x15, 0x91, 0x0a, 0x25, 0x4f, 0xb4, 0x90, 0xca,
	0xa9, 0x75, 0xeb, 0x5e, 0xab, 0xef, 0xf6, 0x6e, 0x11, 0xf6, 0x16, 0x6c, 0x47, 0x0b, 0x28, 0x2b,
	0x8f, 0xb9, 0xbf, 0x2d, 0xb8, 0xff, 0x17, 0x10, 0x1e, 0xc2, 0x26, 0xc5, 0x5a, 0x72, 0x52, 0x8e,
	0x65, 0x98, 0xbd, 0xbb, 0x99, 0x7b, 0xc7, 0xb1, 0x96, 0x33, 0x36, 0x1f, 0x44, 0x84, 0xc6, 0x35,
	0xd7, 0x99, 0x34, 0xcb, 0x6b, 0x33, 0xb3, 0xc6, 0xd7, 0x00, 0x99, 0x07, 0xbe, 0x31, 0xc1, 0xa9,
	0x77, 0x2d, 0xaf, 0xd5, 0x77, 0x56, 0x51, 0xb3, 0xa6, 0x9c, 0x2f, 0xf7, 0x5e, 0xc2, 0xba, 0xa1,
	0x47, 0x1b, 0xea, 0xdf, 0x68, 0x56, 0x98, 0x91, 0x2d, 0x71, 0x17, 0xd6, 0x6f, 0x82, 0x49, 0x4a,
	0x66, 0xa3, 0x26, 0xcb, 0x3f, 0xdc, 0x9f, 0x35, 0xb0, 0x97, 0xda, 0x46, 0x3a, 0xd0, 0xa9, 0xc2,
	0x03, 0x68, 0x84, 0x22, 0x22, 0x33, 0xbd, 0xdd, 0x7f, 0x52, 0xd9, 0xb8, 0x0a, 0xef, 0xbd, 0x13,
	0x11, 0x31, 0x33, 0x81, 0x8f, 0xa1, 0x1d, 0xa6, 0x52, 0x52, 0xac, 0x0b, 0xed, 0xf9, 0x5f, 0x6d,
	0x15, 0x45, 0x23, 0x12, 0x9f, 0x41, 0xc7, 0x34, 0x7d, 0x49, 0xd9, 0x19, 0xf1, 0xf8, 0xca, 0xfc,
	0x62, 0x9b, 0x6d, 0x4f, 0xf2, 0x23, 0x2d, 0xaa, 0xe8, 0x81, 0x2d, 0x2e, 0xfd, 0xcc, 0x11, 0x3f,
	0x08, 0x43, 0x4a, 0x34, 0x45, 0x4e, 0x23, 0x47, 0x8a, 0xcb, 0xf7, 0x5c, 0xab, 0xb7, 0x45, 0x15,
	0x1f, 0x02, 0x48, 0x52, 0xa4, 0x7d, 0xcd, 0xa7, 0xe4, 0xac, 0x77, 0x2d, 0xaf, 0xce, 0x9a, 0xa6,
	0x72, 0xce, 0xa7, 0xe4, 0xbe, 0x80, 0x46, 0x26, 0x12, 0x5b, 0xb0, 0xf9, 0xe9, 0x6c, 0x70, 0x36,
	0xfc, 0x7c, 0x66, 0xaf, 0xe1, 0x06, 0xd4, 0x86, 0x03, 0xdb, 0xc2, 0x6d, 0x80, 0xe1, 0xc5, 0x31,
	0xf3, 0x4f, 0x4f, 0x3e, 0x9c, 0x9c, 0xdb, 0x35, 0x57, 0xc2, 0x4e, 0x29, 0x5e, 0x2a, 0x11, 0xb1,
	0x22, 0xec, 0x42, 0x2b, 0x14, 0x42, 0x46, 0xdc, 0x78, 0x50, 0xf8, 0x5a, 0x2e, 0xe1, 0x1b, 0xb8,
	0xa7, 0x8c, 0x1f, 0x34, 0x8f, 0xd9, 0xfe, 0x1d, 0xc6, 0xb1, 0xc5, 0x80, 0xeb, 0x43, 0x73, 0xb1,
	0x27, 0x3e, 0x87, 0x1d, 0x99, 0xc7, 0x5a, 0xf9, 0x09, 0x49, 0x5f, 0x25, 0x41, 0x1e, 0xeb, 0x36,
	0xeb, 0xcc, 0x1b, 0x1f, 0x49, 0x8e, 0x92, 0x20, 0xc6, 0xa7, 0xd0, 0xc9, 0xda, 0x3e, 0x8f, 0x7d,
	0x45, 0xa1, 0x88, 0xa3, 0x3c, 0x48, 0x75, 0xd6, 0xce, 0xca, 0x27, 0xf1, 0x28, 0x2f, 0xba, 0xc3,
	0x52, 0x80, 0x07, 0x34, 0x9b, 0x5f, 0x9b, 0x83, 0x6a, 0x80, 0x1f, 0x55, 0x34, 0x2f, 0xb1, 0xb7,
	0x63, 0xeb, 0x26, 0xd0, 0xa9, 0xf4, 0xca, 0x99, 0xdb, 0xca, 0x33, 0xf7, 0x3f, 0xb3, 0xdd, 0xff,
	0x65, 0x95, 0xee, 0xfd, 0x88, 0xe4, 0x0d, 0x0f, 0x09, 0x2f, 0xa0, 0x33, 0xba, 0x16, 0xe9, 0x24,
	0x5a, 0xda, 0xb7, 0xbf, 0x92, 0x2c, 0x17, 0xbb, 0xd7, 0x5d, 0x0d, 0xc8, 0x4f, 0xdb, 0x5d, 0xc3,
	0xaf, 0xb0, 0x5b, 0xe1, 0x3d, 0x9c, 0x0d, 0x68, 0x86, 0x2b, 0x9f, 0x8e, 0xa5, 0x19, 0xff, 0xc2,
	0x7f, 0xb8, 0xf9, 0xa5, 0x96, 0x8c, 0x7f, 0x58, 0xd6, 0x78, 0xc3, 0x3c, 0x71, 0xaf, 0xfe, 0x04,
	0x00, 0x00, 0xff, 0xff, 0x2f, 0xb8, 0x13, 0xae, 0xf5, 0x04, 0x00, 0x00,
}
