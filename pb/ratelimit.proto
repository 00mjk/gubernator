// NOTE: Inspired by https://github.com/lyft/ratelimit/blob/master/proto/ratelimit/ratelimit.proto

syntax = "proto3";

option go_package = "pb";

option cc_generic_services = true;

package pb.gubernator;

import "common.proto";

service RateLimitService {
  // Given a rate limit descriptor return a descriptor status
  rpc GetRateLimit (RateLimitRequest) returns (RateLimitResponse) {}

  // Client implementations can use this method if the decriptor key is already known
  rpc GetRateLimitByKey (RateLimitKeyRequest) returns (RateLimitResponse) {}

  // TODO: Implement get peers

  // TODO: Implement config API (In another file)
}

message RateLimitRequest {
  // The domain scopes the request to avoid collisions with other services or applications.
  string domain = 1;
  // Rate limit requests must specify at least one descriptor
  repeated Descriptor descriptors = 2;
}

message RateLimitResponse {
  // A list of DescriptorStatus messages which matches the length of the descriptor list passed
  // in the RateLimitRequest. This can be used by the caller to determine which individual
  // descriptors failed and/or what the currently configured limits are for all of them.
  repeated DescriptorStatus statuses = 2;
}

// This is used by Gubernator clients who already have the domain and descriptors and created a hash key
message RateLimitKeyRequest {
  message Entry {
    // The key identifies the specific rate limit the request is for
    bytes key = 1;
    // Rate limit requests can optionally specify the number of hits a request adds to the matched limit. If the
    // value is not set in the message, a request increases the matched limit by 1.
    int64 hits = 2;
    // This is the rate limit the requested for this descriptor. If the rate limit doesn't currently exist for
    // this descriptor it will be created and enforced for subsequent requests
    RateLimitDuration rate_limit = 3;
  }

  // Requests must specify at least one KeyRequestEntry, but can specify multiple descriptors
  // to be individually evaluated
  repeated Entry entries = 1;
}

// Describes a rate limit
message Descriptor {
  // A map of key value pairs that make up the descriptor
  map<string, string> values = 1;

  // Rate limit requests optionally specify the number of hits a request adds to the matched limit. If the
  // value is not set, a request increases the matched limit by 1.
  int64 hits = 2;

  // This is the rate limit the requested for this descriptor. If the rate limit doesn't currently exist for
  // this descriptor it will be created and enforced for subsequent requests
  RateLimitDuration rate_limit = 3;
}

// The return status of a descriptor submitted via RateLimitRequest
message DescriptorStatus {
  enum Status {
    UNKNOWN = 0;
    OK = 1;
    OVER_LIMIT = 2;
  }

  // The status of this descriptor.
  Status status = 1;
  // The current limit for the requested rate limit.
  int64 current_limit = 2;
  // If Code is not OVER_LIMIT, This is the limit remaining
  int64 limit_remaining = 3;
  // This is the time when the rate limit span will be reset as a unix timestamp.
  int64 reset_time = 4;
  // This is additional metadata that a client might find useful. (IE: Additional headers, corrdinator ownership, etc..)
  map<string, string> metadata = 5;
}

