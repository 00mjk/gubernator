syntax = "proto3";

option go_package = "pb";

option cc_generic_services = true;

package pb.gubernator;

import "google/api/annotations.proto";

service RateLimitService {
  // Given a list of rate limits return the rates and statuses of each request.
  rpc GetRateLimits (RateLimitRequestList) returns (RateLimitResponseList) {
    option (google.api.http) = {
      post: "/v1/GetRateLimits"
      body: "*"
    };
  }


  // This method is for round trip benchmarking and can be used by
  // the client to determine connectivity to the server
  rpc HealthCheck (HealthCheckRequest) returns (HealthCheckResponse) {
    option (google.api.http) = {
      get: "/v1/HealthCheck"
    };
  }
}

// Must specify at least one RateLimitRequest.
message RateLimitRequestList {
  repeated RateLimitRequest rate_limits = 1;
}

// Responses are in the same order as they appeared in the RateLimitsRequest
message RateLimitResponseList {
  repeated RateLimitResponse rate_limits = 1;
}

message RateLimitRequest {
  // The namespace scopes the unique_key to avoid collisions with other services or applications.
  string namespace = 1;

  // Uniquely identifies this rate limit within a namespace.
  string unique_key = 2;

  // Rate limit requests optionally specify the number of hits a request adds to the matched limit. If the
  // value is not set, a request increases the matched limit by 1.
  int64 hits = 3;

  // This is the rate limit configuration provided by the client. The configuration may change on
  // subsequent requests, however when this occurs any previous rate limit counts are reset.
  RateLimitConfig rate_limit_config = 4;
}

// Defines a rate limit duration and requests per duration
message RateLimitConfig {
  enum Algorithm {
    TOKEN_BUCKET = 0;
    LEAKY_BUCKET = 1;
  }

  // The number of requests that can occur for the duration of the rate limit
  int64 limit = 1;

  // The duration of the rate limit in milliseconds
  // Second = 1000 Milliseconds
  // Minute = 60000 Milliseconds
  // Hour = 3600000 Milliseconds
  int64 duration = 2;

  // The algorithm used to calculate the rate limit
  Algorithm algorithm = 3;
}

message RateLimitResponse {
  enum Status {
    UNDER_LIMIT = 0;
    OVER_LIMIT = 1;
  }

  // The status of the rate limit.
  Status status = 1;
  // The currently configured request limit (Identical to RateLimitRequest.rate_limit_config.limit).
  int64 current_limit = 2;
  // This is the number of requests remaining before the limit is hit.
  int64 limit_remaining = 3;
  // This is the time when the rate limit span will be reset, provided as a unix timestamp in milliseconds.
  int64 reset_time = 4;
  // This is additional metadata that a client might find useful. (IE: Additional headers, corrdinator ownership, etc..)
  map<string, string> metadata = 5;
}

message HealthCheckRequest {}
message HealthCheckResponse {
  // Valid entries are 'healthy' or 'unhealthy'
  string status = 1;
  // If 'unhealthy' message indicates the problem
  string message = 2;
  // The number of peers we know about
  int32 peer_count = 3;
}
